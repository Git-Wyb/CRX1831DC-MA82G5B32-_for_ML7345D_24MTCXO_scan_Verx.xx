C51 COMPILER V9.60.0.0   ML7345                                                            03/01/2022 16:31:55 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE ML7345
OBJECT MODULE PLACED IN .\Objects\ML7345.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE user\src\ML7345.c OPTIMIZE(0,SPEED) BROWSE INCDIR(.\include;.\user\inc) 
                    -DEBUG OBJECTEXTEND PRINT(.\Listings\ML7345.lst) OBJECT(.\Objects\ML7345.obj)

line level    source

   1          #include "ML7345.h"
   2          
   3          //#include <stdlib.h>
   4          //#include <stdbool.h> /* For true/false definition                      */
   5          //#include <stdio.h>
   6          #include "spi.h"
   7          #include "gpio.h" // 芯片引脚定于
   8          #include "ram.h"
   9          #include "ID_Decode.h"
  10          #include "Type.h"
  11          #include "uart.h"
  12          
  13          //ROHM demo板 main fre=426.25;Vco Cal Range:425.85 - 431.85.MHz
  14          //TCXO = 24M
  15          xdata u8 Fre_426_075[8] = {0x23,0x08,0x19,0x99,0x23,0x07,0x91,0x11}; //426.075MHz频率设置
  16          xdata u8 Fre_429_350[8] = {0x23,0x0C,0x77,0x77,0x23,0x0B,0xEE,0xEF}; //429.350MHz频率设置
  17          xdata u8 Fre_429_550[8] = {0x23,0x0C,0xBB,0xBC,0x23,0x0C,0x33,0x33}; //429.550MHz频率设置
  18          xdata u8 Fre_426_750[8] = {0x23,0x09,0x00,0x00,0x23,0x08,0x77,0x77}; //426.750MHz频率设置
  19          xdata u8 Fre_429_175[8] = {0x23,0x0c,0x3b,0xbc,0x23,0x0b,0xb3,0x33}; //429.175MHz频率设置
  20          
  21          /**Receiver_vent**/ xdata u8 Receiver_vent_Cache = 0;
  22          xdata u32 SPI_Receive_DataForC[7]; //C郿
  23          xdata u8 SPI_RECEIVE_BUFF[40] = {0};
  24          
  25          /************Address: 0x20000500, Name: GENERIC_PKT_FRAME_CFG1***************************************/
  26          
  27          xdata u8 Radio_Date_Type = 1;
  28          xdata u8 tx_pack_cnt = 0;
  29          xdata u8 Radio_Date_Type_bak=1;
  30          xdata u8 APP_TX_freq=0;
  31          
  32          xdata u8 TX_Scan_step=0;
  33          xdata u8 First_TX_Scan=0;
  34          xdata u8 rf_offset = 0;
  35          
  36          xdata u8 Freq_SetBuff[8] = {0};
  37          /*
  38          Function: RF Init
  39          Parameter: Null
  40          Return: Null
  41          */
  42          /* Initialize: 426MHz General Packet(TCXO_ChStep=12.5kHz_DR=1.2kbps_Dev=0.6kHz_GFSK)
  43             发射功率0dBm */
  44          void RF_ML7345_Init(u8* freq,u8 sync,u8 rx_len)
  45          {
  46   1          ML7345_RESETN_SET();    /* Hardware Reset */
  47   1          while(1){
  48   2              if(ML7345_Read_Reg(0x0Du)&0x01u){   /* Wait Clock stabilization completion */
  49   3                  break;
  50   3              }
  51   2          }
  52   1          ML7345_Write_Reg(0x00,0x11);    /* Bank0 Set */
  53   1          ML7345_Write_Reg(0x01,0xff);    /* Software Reset */
  54   1          ML7345_Write_Reg(0x02,0x9f);    /* Clk Enable */
C51 COMPILER V9.60.0.0   ML7345                                                            03/01/2022 16:31:55 PAGE 2   

  55   1          ML7345_Write_Reg(0x03,0xc3);    /* TCXO_EN */
  56   1          ML7345_Write_Reg(0x04,0x03);    /* MSB first,Format D (non Wireless M-Bus, general purpose format) */
  57   1          ML7345_Write_Reg(0x05,0x10);    /* CRC Disable,Length field 1-byte mode */
  58   1          ML7345_Write_Reg(0x06,0x00);    /* Data Rate: 0x00 1.2kbps; 0x22 4.8kbps */
  59   1          ML7345_Write_Reg(0x07,0x15);    /* GFSK,NRZ */
  60   1          ML7345_Write_Reg(0x08,0x00);    /* Sync word pattern 1,Manchester Do not inverse polarity */
  61   1          ML7345_Write_Reg(0x09,0x00);    /* CH 0 */
  62   1          ML7345_Write_Reg(0x0a,0x18);    /* AUTO_TX_EN */
  63   1          ML7345_Write_Reg(0x0b,0x88);    /* TRX_OFF */
  64   1          ML7345_Write_Reg(0x0c,0x00);    /* FIFO mode */
  65   1          ML7345_Write_Reg(0x0d,0x08);    /* [INT_SOURCE_GRP1],Interrupt status for INT0 to INT7 */
  66   1          ML7345_Write_Reg(0x0e,0x00);    /* [INT_SOURCE_GRP2],Interrupt status for INT8 to INT15 (RX) */
  67   1          ML7345_Write_Reg(0x0f,0x00);    /* [INT_SOURCE_GRP3],Interrupt status for INT16 to INT23 (TX) */
  68   1          ML7345_Write_Reg(0x10,0x00);    /* masking interrupt,[INT_EN_GRP1]Interupt mask for INT0 to INT7 */
  69   1          ML7345_Write_Reg(0x11,0x00);    /* masking interrupt,[INT_EN_GRP2]Interupt mask for INT8 to INT15 */
  70   1          ML7345_Write_Reg(0x12,0x00);    /* masking interrupt,[INT_EN_GRP3]Interupt mask for INT16 to INT23 */
  71   1          ML7345_Write_Reg(0x13,0x00);    /* [CRC_ERR_H]CRC error status (high byte) */
  72   1          ML7345_Write_Reg(0x14,0x00);    /* [CRC_ERR_M]CRC error status (middle byte)*/
  73   1          ML7345_Write_Reg(0x15,0x00);    /* [CRC_ERR_L]CRC error status (low byte)*/
  74   1          ML7345_Write_Reg(0x16,0x00);    /* State clear control */
  75   1          ML7345_Write_Reg(0x17,0x00);    /* TX FIFO-Full level setting */
  76   1          ML7345_Write_Reg(0x18,0x00);    /* TX FIFO-Empty level setting and TX trigger level setting in FAST_TX
             - mode */
  77   1          ML7345_Write_Reg(0x19,0x00);    /* RX FIFO-Full level disable and level setting */
  78   1          ML7345_Write_Reg(0x1a,0x00);    /* RX FIFO-Empty level disable and level setting (high byte) */
  79   1      
  80   1          ML7345_Write_Reg(0x2d,0x06);    /* SLEEP execution and Wake-up operation setting */
  81   1          /* Preamble */
  82   1          ML7345_Write_Reg(0x3f,0x05);    /* Preamble pattern setting,p198*/
  83   1      
  84   1          ML7345_Write_Reg(0x41,0x8B);    /* Enable ED value calculation,bit3=0 ED value constantly updated,bit3
             -=1 ED value acquired at SyncWord detection timing*/
  85   1      
  86   1          ML7345_Write_Reg(0x42,0x00);    //TX前导码长度高八位
  87   1          ML7345_Write_Reg(0x43,0x34);    //TX前导码长度低八位,不等少于16个位,TX preamble length =
             - (specified value x2) bits
  88   1          //----------------------------------------------------------------------------------------------------
             --
  89   1          ML7345_Write_Reg(0x45,0x08);    //接收前导码长度(bit) RX preamble setting and ED threshold chec
             -k setting
  90   1          //----------------------------------------------------------------------------------------------------
             --
  91   1          ML7345_Write_Reg(0x4e,0x00);    /* GPIO0 [output] “L” level */
  92   1          ML7345_Write_Reg(0x4f,0x00);    /* GPIO1 [output] “L” level,Upon reset,disable GPIO1 pin is CLK_OU
             -T function */
  93   1          ML7345_Write_Reg(0x50,0x00);    /* GPIO2 [output] “L” level */
  94   1          ML7345_Write_Reg(0x51,0x00);    /* GPIO3 [output] “L” level */
  95   1      
  96   1          ML7345_Write_Reg(0x54,0x14);    /* Channel filter bandwidth setting */
  97   1      
  98   1          ML7345_Write_Reg(0x60,0x06); /* Decimation gain setting 提高灵敏度 */
  99   1      
 100   1          ML7345_Write_Reg(0x63,0x88);    /* Fine adjustment of load capacitance for oscillation circuits */
 101   1      
 102   1          ML7345_Write_Reg(0x67,0x16);    /* 功率设置12dbm */
 103   1          ML7345_Write_Reg(0x68,0x10);    /* PA regulator fine adjustment */
 104   1          ML7345_Write_Reg(0x69,0x03);    /* PA gain adjustment */
 105   1      
 106   1          ML7345_Write_Reg(0x6e,0x5b);    /*5b VCO calibration setting or status indication */
 107   1      
 108   1          ML7345_Write_Reg(0x7a,0x00);    //发送包长度高八位
 109   1          ML7345_Write_Reg(0x7b,0x0c);    //发送包长度低八位
C51 COMPILER V9.60.0.0   ML7345                                                            03/01/2022 16:31:55 PAGE 3   

 110   1      
 111   1          ML7345_Write_Reg(0x7d,0x00);    //接收包长度高八位
 112   1          ML7345_Write_Reg(0x7e,rx_len);    //接收包长度低八位
 113   1      
 114   1          /***************************************************************************************************/
 115   1      
 116   1          ML7345_Write_Reg(0x00,0x22);    /* Bank1 Set */
 117   1          ML7345_Write_Reg(0x02,0x07);    /* TX data rate conversion setting (high 4bits) */
 118   1          ML7345_Write_Reg(0x03,0xd0);    /* TX data rate conversion setting (low byte) */
 119   1          ML7345_Write_Reg(0x04,0x00);    /* RX data rate concversion setting 1 (high 4bits) */
 120   1          ML7345_Write_Reg(0x05,0x50);    /* RX data rate cnvesrion setting 1 (low byte) */
 121   1      
 122   1          ML7345_Write_Reg(0x11,0x27);    /* RSSI offset value setting during low gain operation */
 123   1      
 124   1          ML7345_Write_Reg(0x13,0x0c);    /* Scale factor setting for ED value conversion */
 125   1      
 126   1          ML7345_Write_Reg(0x1a,0x02);    /* Divide 2,PLL frequency division setting */
 127   1          /* 426.075MHz */
 128   1          ML7345_Write_Reg(0x1b,freq[0]);    /* TX frequency setting (I counter),p67-69 */
 129   1          ML7345_Write_Reg(0x1c,freq[1]);    /* TX frequency setting (F counter high 4bit) */
 130   1          ML7345_Write_Reg(0x1d,freq[2]);    /* TX frequency setting (F counter middle byte) */
 131   1          ML7345_Write_Reg(0x1e,freq[3]);    /* TX frequency setting (F counter low byte) */
 132   1          ML7345_Write_Reg(0x1f,freq[0]);    /* RX frequency setting (I counter) */
 133   1          ML7345_Write_Reg(0x20,freq[1]);    /* RX frequency setting (F counter high 4bit)  */
 134   1          ML7345_Write_Reg(0x21,freq[2]);    /* RX frequency setting (F counter middle byte) */
 135   1          ML7345_Write_Reg(0x22,freq[3]);    /* RX frequency setting (F counter low byte) */
 136   1      
 137   1          ML7345_Write_Reg(0x23,0x08);    /* 25KHz,Channel space setting (high byte) */
 138   1          ML7345_Write_Reg(0x24,0x88);    /* Channel space setting (low byte) */
 139   1          /* SyncWord 0x00005515 */
 140   1          ML7345_Write_Reg(0x25,0x08);    /* SyncWord length setting */
 141   1          ML7345_Write_Reg(0x26,0x0f);    /* SyncWord enable setting */
 142   1          ML7345_Write_Reg(0x27,0x00);    /* SyncWord #1 setting (bit24 to 31) */
 143   1          ML7345_Write_Reg(0x28,0x00);    /* SyncWord #1 setting (bit16 to 23) */
 144   1          ML7345_Write_Reg(0x29,0x00);    /* SyncWord #1 setting (bit8 to 15) */
 145   1          ML7345_Write_Reg(0x2a,sync);    /* SyncWord #1 setting (bit0 to 7) */
 146   1      
 147   1          ML7345_Write_Reg(0x2f,0x08);    /* GFSK clock setting x8 clock,GFSK/FSK modulation timing resolution s
             -etting */
 148   1          ML7345_Write_Reg(0x30,0x00);    /* GFSK frequency deviation setting (high 6bits) */
 149   1          ML7345_Write_Reg(0x31,0xAE);    /* P71  GFSK frequency deviation:2.0KHz,GFSK frequency deviation setti
             -ng (low byte) */
 150   1      
 151   1          /*(Channel#0 frequency-400khz)426.075:0x23 0x07 0x91 0x11;
 152   1          426.25:0x23 0x07 0xcc 0xcc */
 153   1          ML7345_Write_Reg(0x4d,freq[4]);    /* VCO calibration low limit frequency setting (I counter),p254 */
 154   1          ML7345_Write_Reg(0x4e,freq[5]);    /* VCO calibration low limit frequency setting (F counter high 4bit
             -s) */
 155   1          ML7345_Write_Reg(0x4f,freq[6]);    /* VCO calibration low limit frequency setting (F counter middle by
             -te) */
 156   1          ML7345_Write_Reg(0x50,freq[7]);    /* VCO calibration low limit frequency setting (F counter low byte)
             - */
 157   1          ML7345_Write_Reg(0x51,0x04);    /* 6 MHz,VCO calibration upper limit frequency setting */
 158   1          ML7345_Write_Reg(0x52,0x5a);    /* VCO calibration low limit value indication and setting */
 159   1          ML7345_Write_Reg(0x53,0x66);    /* VCO calibration upper limit value indication and setting */
 160   1      
 161   1          ML7345_Write_Reg(0x5c,0x15);    /* 0x10 Demodulator configulation 6 */
 162   1          ML7345_Write_Reg(0x5d,0x1b);    /* 0x1b Demodulator configulation 7 */
 163   1          ML7345_Write_Reg(0x5e,0x05);    /* 0x05 Demodulator configuration 8 */
 164   1          ML7345_Write_Reg(0x5f,0x67);    /* 0x67 Demodulator configulation 9 */
 165   1          ML7345_Write_Reg(0x60,0x0c);    /* Demodulator configulation 10 */
 166   1      
C51 COMPILER V9.60.0.0   ML7345                                                            03/01/2022 16:31:55 PAGE 4   

 167   1          SetReg_Rssi();  //2021.11.17 ROHM提出必要设置,否则读取RSSI偏差大。
 168   1      
 169   1          ML7345_Write_Reg(0x00,0x44); //bank2
 170   1          ML7345_Write_Reg(0x2a,0x0f); //2019.11.25 ROHM提出设置,设置之后灵敏度提升了2dBm
 171   1      
 172   1          /* 以下寄存器值为发送功率必要设置，不然发送功率偏差大 */
 173   1          ML7345_Write_Reg(0x00,0x44); //bank2
 174   1          ML7345_Write_Reg(0x4f,0x00);
 175   1      
 176   1          ML7345_Write_Reg(0x00,0x88); //bank3
 177   1          ML7345_Write_Reg(0x2f,0x3f);
 178   1          ML7345_Write_Reg(0x0c,0x41);
 179   1          ML7345_Write_Reg(0x0d,0x33);
 180   1          ML7345_Write_Reg(0x0e,0x54);
 181   1          ML7345_Write_Reg(0x14,0x10);
 182   1          ML7345_Write_Reg(0x24,0x03);
 183   1          ML7345_Write_Reg(0x7e,0x00);
 184   1      
 185   1          if((PROFILE_CH_FREQ_32bit_200002EC == 429350000) || (PROFILE_CH_FREQ_32bit_200002EC == 429550000)) ML7
             -345_DataRate_Set_4_8k();
 186   1          else    ML7345_DataRate_Set_1_2k();
 187   1          /*****************************************************/
 188   1      
 189   1          ML7345_Write_Reg(0x00, 0x11);     /* BANK_SEL(BANK0) */
 190   1          ML7345_Write_Reg(0x6f, 0x01);     /* VCO_CAL_START(CAL start) */
 191   1          while(1){
 192   2              if(ML7345_Read_Reg(0x0Du)&0x02u){   /* Wait VCO calibration completion */
 193   3                  break;
 194   3              }
 195   2          }
 196   1          ML7345_AllStateFlag_Clear(); //清除所有标志
 197   1      }
 198          
 199          void ML7345_MeasurBER_Init(void)
 200          {
 201   1          ML7345_Write_Reg(ADDR_BANK_SEL,BANK1_SEL);
 202   1          ML7345_Write_Reg(0x0e,0x00);
 203   1      
 204   1          ML7345_Write_Reg(ADDR_BANK_SEL,BANK3_SEL);
 205   1          ML7345_Write_Reg(0x0d,0x33);
 206   1      
 207   1          ML7345_Write_Reg(ADDR_BANK_SEL,BANK0_SEL);
 208   1          ML7345_Write_Reg(0x0c,0x40); //50   /* DIO_SET, continuous output mode,DCLK is constantly output,no OU
             -TPUT (NOT stop output)*/
 209   1          ML7345_Write_Reg(0x4d,0x80); //80
 210   1      
 211   1          ML7345_Write_Reg(0x4E,0x05);    //ML7345D GPIO0 DCLK
 212   1          ML7345_Write_Reg(0x51,0x04);    //ML7345D GPIO3 DIO
 213   1      }
 214          
 215          
 216          void DataReceive(void)
 217          {
 218   1          static u8 StateCache = 0;
 219   1          static u8 Cache = 0;
 220   1          static u8 X_HISbyte = 0;
 221   1          switch (StateCache)
 222   1          {
 223   2              case 0:
 224   2              {
 225   3                  Cache <<= 1;
 226   3                  if (ML7345_DATA)
C51 COMPILER V9.60.0.0   ML7345                                                            03/01/2022 16:31:55 PAGE 5   

 227   3                      Cache++;
 228   3                  if (Cache == 0x55)
 229   3                  {
 230   4                      StateCache = 1;
 231   4                      X_HISbyte = 0;
 232   4                      Cache = 0;
 233   4                  }
 234   3              }
 235   2              break;
 236   2              case 1:
 237   2              {
 238   3                  if (ML7345_DATA != X_HISbyte)
 239   3                      X_ERR++;
 240   3                  X_COUNT++;
 241   3                  X_HISbyte ^= 1;
 242   3                  if (X_COUNT >= 1000)
 243   3                      StateCache = 2;
 244   3              }
 245   2              break;
 246   2              case 2:
 247   2                  if (X_COUNT == 0)
 248   2                      StateCache = 0;
 249   2                  break;
 250   2              default:
 251   2                  break;
 252   2          }
 253   1      }
 254          
 255          
 256          
 257          void Tx_Data_Test(u8 mode)
 258          {
 259   1          ML7345_Write_Reg(0x00, 0x11);     /* BANK_SEL(BANK0) */
 260   1          switch(mode)
 261   1          {
 262   2              /* 发送：载波 */
 263   2              case 0: ML7345_Write_Reg(ADDR_RF_TEST_MODE,0x21);break;
 264   2      
 265   2              /* 发送：0101 */
 266   2              case 1:ML7345_Write_Reg(ADDR_RF_TEST_MODE,0x11);break;
 267   2      
 268   2              /* 发送：0 */
 269   2              case 2:ML7345_Write_Reg(ADDR_RF_TEST_MODE,0x09);break;
 270   2      
 271   2              /* 发送：1 */
 272   2              case 3: ML7345_Write_Reg(ADDR_RF_TEST_MODE,0x05);break;
 273   2      
 274   2               /* 发送：随机 */
 275   2              default:
 276   2                  ML7345_Write_Reg(ADDR_RF_TEST_MODE,0x03);
 277   2               break;
 278   2          }
 279   1          ML7345_SetAndGet_State(TX_ON);
 280   1      }
 281          
 282          
 283          void RF_Ber_Test(void)
 284          {
 285   1          if (X_COUNT >= 1000)
 286   1          {
 287   2              if (X_ERR >= 50) Receiver_LED_RX = 0;
 288   2              else             Receiver_LED_RX = 1;
C51 COMPILER V9.60.0.0   ML7345                                                            03/01/2022 16:31:55 PAGE 6   

 289   2              X_ERR = 0;
 290   2              X_COUNT = 0;
 291   2              X_ERRTimer = 1250;
 292   2          }
 293   1          if (X_ERRTimer == 0)
 294   1              Receiver_LED_RX = 0;
 295   1      }
 296          
 297          void Uart_RF_Ber_Test(void)
 298          {
 299   1          if (X_COUNT >= 1000)
 300   1          {
 301   2              if(X_ERR > 255)  X_ERR_CNT = 255;
 302   2              else X_ERR_CNT = X_ERR;
 303   2      
 304   2              if (X_ERR >= 50) Receiver_LED_RX = 0;
 305   2              else             Receiver_LED_RX = 1;
 306   2      
 307   2              X_ERR = 0;
 308   2              X_COUNT = 0;
 309   2              X_ERRTimer = 1250;
 310   2          }
 311   1          if (X_ERRTimer == 0)
 312   1              Receiver_LED_RX = 0;
 313   1      }
 314          
 315          void APP_TX_PACKET(void)
 316          {
 317   1           xdata char rssi;
 318   1               xdata u8 i=2,j=0;
 319   1      
 320   1               if((TP3==0)&&(FLAG_Key_TP3==0))FLAG_Key_TP3=1;
 321   1      
 322   1            if((Time_error_read_timeout==0)&&(Flag_ERROR_Read==1))
 323   1            {
 324   2                      Flag_ERROR_Read=0;
 325   2                      FLAG_APP_TX_fromUART_err_read=0;
 326   2            }
 327   1            if( (Flag_FREQ_Scan==0) && ((PROFILE_CH_FREQ_32bit_200002EC == 429350000)||(PROFILE_CH_FREQ_32bit_20
             -0002EC == 429550000)) &&
 328   1                        ((FLAG_APP_TX_fromUART_err_read==1) && (Flag_ERROR_Read==1) && (Time_error_read_gap==0) && ((FLAG_AP
             -P_RX==1)||(FLAG_APP_RXstart==1)) && (Radio_Date_Type_bak==2))
 329   1                         )
 330   1            {
 331   2               for(j=0;j<8;j++)Last_Uart_Struct_DATA_Packet_Contro.Data[j/2].uc[j%2]=0x00;
 332   2      
 333   2               Last_Uart_Struct_DATA_Packet_Contro.Fno_Type.UN.type=0x1f;
 334   2                       Last_Uart_Struct_DATA_Packet_Contro.Data[0].uc[0]=0x98;
 335   2                       ERROR_Read_sendTX_packet++;
 336   2                       Last_Uart_Struct_DATA_Packet_Contro.Data[0].uc[1]=ERROR_Read_sendTX_packet;
 337   2                       while(ERROR_Read_sendTX_count<UART_DATA_ID98[1]-4)
 338   2                       {
 339   3                           Last_Uart_Struct_DATA_Packet_Contro.Data[i/2].uc[i%2]=UART_DATA_ID98[ERROR_Read_sendTX_count+4];
 340   3                               ERROR_Read_sendTX_count++;
 341   3                               i++;
 342   3                               if(i==8)break;
 343   3                       }
 344   2                       if(ERROR_Read_sendTX_count==UART_DATA_ID98[1]-4)
 345   2                       {
 346   3                              Last_Uart_Struct_DATA_Packet_Contro.Data[0].uc[1]= Last_Uart_Struct_DATA_Packet_Contro.Data[0].uc[1] |
             -0x80;
 347   3                              FLAG_APP_TX_fromUART_err_read=0;
C51 COMPILER V9.60.0.0   ML7345                                                            03/01/2022 16:31:55 PAGE 7   

 348   3                              Flag_ERROR_Read=0;
 349   3                       }
 350   2      
 351   2                       DEF_APP_TX_freq=3;
 352   2                       FLAG_APP_TX=1;
 353   2                       FLAG_APP_RX=0;
 354   2                       //FLAG_APP_RXstart=0;
 355   2                       APP_TX_freq=0;
 356   2                       TX_Scan_step=1;
 357   2                       First_TX_Scan=0;
 358   2      
 359   2                }
 360   1            else if((Flag_FREQ_Scan==0)&&((PROFILE_CH_FREQ_32bit_200002EC == 429350000)||(PROFILE_CH_FREQ_32bit_
             -200002EC == 429550000))&&
 361   1                        (((FLAG_APP_TX_fromOUT==1)&&(TIME_APP_TX_fromOUT==0))||(FLAG_Key_TP3==1)||
 362   1                         //((FLAG_APP_TX_fromUART==1)&&(((TIME_APP_TX_fromOUT==0)&&(Radio_Date_Type_bak==2))||((TIMER300ms==
             -0)&&(Radio_Date_Type_bak==1)))&&(Uart_Struct_DATA_Packet_Contro.data[0].ui!=Last_Uart_Struct_DATA_Packet_Contro.data[0].
             -ui))
 363   1                         ((FLAG_APP_TX_fromUART==1)&&(((TIME_APP_TX_fromOUT==0)&&(Radio_Date_Type_bak==2))||((TIMER300ms==0)
             -&&(Radio_Date_Type_bak==1))))
 364   1                        )
 365   1                      )
 366   1                {
 367   2                                                FLAG_APP_TX_fromUART=0;
 368   2                                                FLAG_Key_TP3=0;
 369   2                                                Last_Uart_Struct_DATA_Packet_Contro=Uart_Struct_DATA_Packet_Contro;
 370   2                                                Last_Uart_Struct_DATA_Packet_Contro.Fno_Type.UN.type=1;
 371   2                                                rssi=(RAM_RSSI_AVG - 255)/3 - 51;
 372   2                            rssi = -rssi;
 373   2                                                if(Radio_Date_Type_bak==2)rssi= rssi | 0x80;
 374   2                                                Last_Uart_Struct_DATA_Packet_Contro.Data[1].uc[0]= rssi;
 375   2                                                if(FLAG_APP_TX_fromOUT==1) Last_Uart_Struct_DATA_Packet_Contro.Fno_Type.UN.fno= Struct_DATA_Packet_
             -Contro_fno;
 376   2                                                FLAG_APP_TX_fromOUT=0;
 377   2                                                TIME_APP_TX_fromOUT=0;
 378   2      
 379   2                                                DEF_APP_TX_freq=3;
 380   2                                                FLAG_APP_TX=1;
 381   2                                                FLAG_APP_RX=0;
 382   2                                                APP_TX_freq=0;
 383   2                                                TX_Scan_step=1;
 384   2                                                First_TX_Scan=0;
 385   2      
 386   2                            RSSI_Read_Counter = 0;
 387   2                            RAM_RSSI_SUM = 0;
 388   2                }
 389   1          if(FLAG_APP_TX == 1)
 390   1          {
 391   2              if(TX_Scan_step==1)TX_Scan_step=2;
 392   2                         if(TX_Scan_step==2)
 393   2                         {
 394   3                                      if(APP_TX_freq==0)
 395   3                                      {
 396   4                          Flag_tx_en = 1;
 397   4                          TIMER18ms = 300;
 398   4                                          Receiver_LED_TX = 1;
 399   4                                              TX_DataLoad_HighSpeed(ID_SCX1801_DATA,Last_Uart_Struct_DATA_Packet_Contro, &CONST_TXPACKET_DATA_20000
             -AF0[0]);
 400   4                          ML7345_SetAndGet_State(Force_TRX_OFF);
 401   4                          ML7345_Write_Reg(0x00,0x22);    // Bank1 Set
 402   4                          ML7345_Write_Reg(0x2a,0x15);    //sync
 403   4                          ML7345_Write_Reg(ADDR_BANK_SEL,BANK0_SEL);
C51 COMPILER V9.60.0.0   ML7345                                                            03/01/2022 16:31:55 PAGE 8   

 404   4                          ML7345_GPIO0TxDoneInt_Enable();
 405   4                          ML7345_AutoTx_Data(CONST_TXPACKET_DATA_20000AF0,28);
 406   4                          Time_Tx_Out = 100;
 407   4                                              APP_TX_freq=1; //1
 408   4                                      }
 409   3                                      else if((APP_TX_freq < DEF_APP_TX_freq) && (Flag_TxDone == 1) && (Time_APP_blank_TX == 0))
 410   3                                      {
 411   4                          Flag_TxDone = 0;
 412   4                          ML7345_AutoTx_Data(CONST_TXPACKET_DATA_20000AF0,28);
 413   4                          Time_Tx_Out = 100;
 414   4                                              APP_TX_freq++;
 415   4                                      }
 416   3                                      else if((APP_TX_freq == DEF_APP_TX_freq) && (Flag_TxDone == 1) && (Time_APP_blank_TX == 0))
 417   3                                      {
 418   4                          Flag_TxDone = 0;
 419   4                          APP_TX_freq++;
 420   4                          FLAG_APP_RXstart=1;
 421   4                          FLAG_APP_TX=0;
 422   4                          Time_APP_RXstart=1;
 423   4                          Receiver_LED_TX = 0;
 424   4                          FLAG_APP_TX_once=0;
 425   4                          Flag_tx_en = 0;
 426   4                                      }
 427   3                         }
 428   2          }
 429   1          if((FLAG_APP_RXstart==1)&&(Time_APP_RXstart==0)&&(FLAG_APP_TX_fromUART_err_read==0))
 430   1          {
 431   2              FLAG_APP_RXstart = 0;
 432   2              FLAG_APP_RX = 1;
 433   2          }
 434   1          else if(Flag_tx_en == 1 && Time_Tx_Out == 0 && Flag_TxDone == 0 && FLAG_APP_RXstart == 0)
 435   1          {
 436   2              if(PROFILE_CH_FREQ_32bit_200002EC == 429350000) RF_ML7345_Init(Fre_429_350,0x15,28);
 437   2              else if(PROFILE_CH_FREQ_32bit_200002EC == 429550000) RF_ML7345_Init(Fre_429_550,0x15,28);
 438   2              ML7345_GPIO0TxDoneInt_Enable();
 439   2              ML7345_AutoTx_Data(CONST_TXPACKET_DATA_20000AF0,28);
 440   2              Time_Tx_Out = 100;
 441   2              retx_cnt++;
 442   2              if(retx_cnt >= 3)
 443   2              {
 444   3                  retx_cnt = 0;
 445   3                  Flag_tx_en = 0;
 446   3                  FLAG_APP_RX = 1;
 447   3                  Receiver_LED_TX = 0;
 448   3              }
 449   2          }
 450   1      }
 451          
 452          //--------------------------------------------------------------------------------------------------
 453          void ML7345D_RF_test_mode(void)
 454          {
 455   1          Receiver_LED_OUT = 1;
 456   1          Flag_test_mode = 0;
 457   1          Flag_test_pc = 0;
 458   1          while (Receiver_test == 0)
 459   1          {
 460   2              if(Flag_test_mode == 0)
 461   2              {
 462   3                  //UART1_INIT_TestMode();
 463   3                  Receiver_LED_OUT = 0;
 464   3                  BEEP_Module(500,1);
 465   3              }
C51 COMPILER V9.60.0.0   ML7345                                                            03/01/2022 16:31:55 PAGE 9   

 466   2              Flag_test_mode = 1;
 467   2              ClearWDT();   // Service the WDT
 468   2              if(Flag_test_pc == 0)
 469   2              {
 470   3                  if (TP4 == 0) //test  TX
 471   3                  {
 472   4                      if (TP3 == 0)
 473   4                          Tx_Rx_mode = 0;
 474   4                      else
 475   4                          Tx_Rx_mode = 1;
 476   4                  }
 477   3                  else //test  RX
 478   3                  {
 479   4                      if (TP3 == 0)
 480   4                          Tx_Rx_mode = 2;
 481   4                      else
 482   4                          Tx_Rx_mode = 3;
 483   4                  }
 484   3                  if ((Tx_Rx_mode == 0) || (Tx_Rx_mode == 1))
 485   3                  {
 486   4                      CG2214M6_USE_T;
 487   4                      FG_test_rx = 0;
 488   4                      Receiver_LED_RX = 0;
 489   4                      FG_test_tx_off = 0;
 490   4                      Flag_test_rssi = 0;
 491   4                      PROFILE_CH_FREQ_32bit_200002EC = 429175000;
 492   4                      if (Tx_Rx_mode == 0) //发载波，无调制信叿
 493   4                      {
 494   5                          Receiver_LED_TX = 1;
 495   5                          FG_test_mode = 0;
 496   5                          FG_test_tx_1010 = 0;
 497   5                          if (FG_test_tx_on == 0)
 498   5                          {
 499   6                              FG_test_tx_on = 1;
 500   6                              ML7345_SetAndGet_State(Force_TRX_OFF);
 501   6                              ML7345_Frequency_Set(Fre_429_175,1);
 502   6                              Tx_Data_Test(0);
 503   6                          }
 504   5                      }
 505   4                      else //发载波，有调制信叿
 506   4                      {
 507   5                          if (TIMER1s == 0)
 508   5                          {
 509   6                              TIMER1s = 500;
 510   6                              Receiver_LED_TX = !Receiver_LED_TX;
 511   6                          }
 512   5                          FG_test_mode = 1;
 513   5                          FG_test_tx_on = 0;
 514   5                          if (FG_test_tx_1010 == 0)
 515   5                          {
 516   6                              FG_test_tx_1010 = 1;
 517   6                              ML7345_SetAndGet_State(Force_TRX_OFF);
 518   6                              ML7345_Frequency_Set(Fre_429_175,1);
 519   6                              Tx_Data_Test(1);
 520   6                          }
 521   5                      }
 522   4                  }
 523   3                  //else  {           //test  RX
 524   3                  if ((Tx_Rx_mode == 2) || (Tx_Rx_mode == 3))
 525   3                  {
 526   4                      CG2214M6_USE_R;
 527   4                      FG_test_rx = 1;
C51 COMPILER V9.60.0.0   ML7345                                                            03/01/2022 16:31:55 PAGE 10  

 528   4                      Receiver_LED_TX = 0;
 529   4                      FG_test_mode = 0;
 530   4                      FG_test_tx_on = 0;
 531   4                      FG_test_tx_1010 = 0;
 532   4                      if (FG_test_tx_off == 0)
 533   4                      {
 534   5                          FG_test_tx_off = 1;
 535   5                          ML7345_SetAndGet_State(Force_TRX_OFF);
 536   5                          PROFILE_CH_FREQ_32bit_200002EC = 426750000;
 537   5                          ML7345_Frequency_Set(Fre_426_750,1);
 538   5                          ML7345_MeasurBER_Init();
 539   5                          ML7345_SetAndGet_State(RX_ON);
 540   5                      }
 541   4                      if (Tx_Rx_mode == 2) //packet usart out put RSSI
 542   4                      {
 543   5                          if (TIMER1s == 0)
 544   5                          {
 545   6                              TIMER1s = 500;
 546   6                              Receiver_LED_RX = !Receiver_LED_RX;
 547   6                          }
 548   5                          //SCAN_RECEIVE_PACKET(); //扫描接收数据
 549   5                      }
 550   4                      if (Tx_Rx_mode == 3) //packet usart out put BER
 551   4                      {
 552   5                          RF_Ber_Test();
 553   5                      }
 554   4                  }
 555   3              }
 556   2              PC_PRG();
 557   2          }
 558   1          if(Flag_test_mode == 1)
 559   1          {
 560   2              //UART1_INIT();
 561   2              ML7345_SetAndGet_State(Force_TRX_OFF);
 562   2              RF_ML7345_Init(Fre_426_075,0x55,12);
 563   2          }
 564   1          PROFILE_CH_FREQ_32bit_200002EC = 426075000;
 565   1      
 566   1          Flag_test_mode = 0;
 567   1          Flag_test_pc = 0;
 568   1          ML7345_GPIO0RxDoneInt_Enable(); /* 开启接收完成中断,ML7345D GPIO0中断输出 */
 569   1          ML7345_GPIO0TxDoneInt_Enable(); /* 开启发送完成中断,ML7345D GPIO0中断输出 */
 570   1          FG_test_rx = 0;
 571   1          TIMER1s = 0;
 572   1          Receiver_LED_TX = 0;
 573   1          Receiver_LED_RX = 0;
 574   1          FG_Receiver_LED_RX = 0;
 575   1          //Receiver_LED_OUT = 0;
 576   1          Time_rf_init = 1000;
 577   1          FLAG_APP_RX = 1;
 578   1      }
 579          
 580          void ML7345d_Change_Channel(void)
 581          {
 582   1          if ((FLAG_ID_Erase_Login == 1) || (FLAG_ID_Login == 1) ||(FLAG_ID_SCX1801_Login==1))
 583   1          {
 584   2              PROFILE_CH_FREQ_32bit_200002EC = 426075000;
 585   2              Radio_Date_Type=1;
 586   2              Channels=1;
 587   2              ML7345_Frequency_Set(Fre_426_075,Radio_Date_Type);
 588   2          }
 589   1          else
C51 COMPILER V9.60.0.0   ML7345                                                            03/01/2022 16:31:55 PAGE 11  

 590   1          {
 591   2              switch(Channels)
 592   2              {
 593   3                  case 1:
 594   3                          Radio_Date_Type = 1;
 595   3                          PROFILE_CH_FREQ_32bit_200002EC = 426075000;
 596   3                          ML7345_Frequency_Set(Fre_426_075,Radio_Date_Type);       //加上VCO校准后用时5ms
             -，不加1.2ms
 597   3                          if(ID_SCX1801_DATA == 0) Channels = 1;
 598   3                          else Channels = 2;
 599   3                          break;
 600   3      
 601   3                  case 2:
 602   3                          Radio_Date_Type = 2;
 603   3                          PROFILE_CH_FREQ_32bit_200002EC = 429350000;
 604   3                          ML7345_Frequency_Set(Fre_429_350,Radio_Date_Type);
 605   3                          Channels = 3;
 606   3                          break;
 607   3      
 608   3                  case 3:
 609   3                          Radio_Date_Type = 2;
 610   3                          PROFILE_CH_FREQ_32bit_200002EC = 429550000;
 611   3                          ML7345_Frequency_Set(Fre_429_550,Radio_Date_Type);
 612   3                          Channels = 4;
 613   3                          break;
 614   3      
 615   3                   case 4:
 616   3                          Radio_Date_Type = 1;
 617   3                          PROFILE_CH_FREQ_32bit_200002EC = 426075000;
 618   3                          ML7345_Frequency_Set(Fre_426_075,Radio_Date_Type);
 619   3                          Channels = 1;
 620   3                          break;
 621   3      
 622   3                   default:
 623   3                      break;
 624   3              }
 625   2          }
 626   1      }
 627          
 628          void ML7345D_Freq_Scanning(void)
 629          {
 630   1          if(TIMER18ms == 0)
 631   1          {
 632   2              if(Flag_FREQ_Scan)  return;
 633   2              ML7345d_Change_Channel();
 634   2              if(Time_rf_init == 0)
 635   2              {
 636   3                  Time_rf_init = 1000;
 637   3                  if(PROFILE_CH_FREQ_32bit_200002EC == 426075000) RF_ML7345_Init(Fre_426_075,0x55,12);
 638   3                  else if(PROFILE_CH_FREQ_32bit_200002EC == 429350000) RF_ML7345_Init(Fre_429_350,0x55,28);
 639   3                  else if(PROFILE_CH_FREQ_32bit_200002EC == 429550000) RF_ML7345_Init(Fre_429_550,0x55,28);
 640   3                  ML7345_GPIO0RxDoneInt_Enable();
 641   3              }
 642   2              ML7345_SetAndGet_State(RX_ON);
 643   2              CG2214M6_USE_R;
 644   2      
 645   2              if(Radio_Date_Type==1)
 646   2                  TIMER18ms = 18;
 647   2              else if(Radio_Date_Type > 1)
 648   2                  TIMER18ms = 18;
 649   2              Flag_rx_pream = 0;
 650   2              Flag_tx_en = 0;
C51 COMPILER V9.60.0.0   ML7345                                                            03/01/2022 16:31:55 PAGE 12  

 651   2              RSSI_Read_Counter = 0;
 652   2              RAM_RSSI_SUM = 0;
 653   2      
 654   2          }else Flag_FREQ_Scan = 0;
 655   1      }
 656          
 657          //idata u8 red = 0;
 658          void ML7345_TRX_Del(void)
 659          {
 660   1          idata u8 reg = 0;
 661   1          if(Flag_tx_en == 0) reg = RF_SyncWord_DONE();
 662   1      
 663   1          if(reg == 0x20)
 664   1          {
 665   2              TIMER18ms = 550;
 666   2              Flag_FREQ_Scan = 1;
 667   2              if(Flag_rx_pream == 0 && Flag_set_freq == 0)
 668   2              {
 669   3                  FG_Receiver_LED_RX = 1;
 670   3                  ML7345_SetAndGet_State(Force_TRX_OFF);
 671   3                  if(PROFILE_CH_FREQ_32bit_200002EC == 426075000)
 672   3                  {
 673   4                      TIMER300ms = 600;
 674   4                      if(Flag_TX_ID_load == 0)    RF_ML7345_Init(Fre_426_075,0x15,12);
 675   4                      else                        RF_ML7345_Init(Fre_426_075,0x15,24);
 676   4                  }
 677   3                  else if(PROFILE_CH_FREQ_32bit_200002EC == 429350000)   {RF_ML7345_Init(Fre_429_350,0x15,28); T
             -IMER300ms = 100;}
 678   3                  else if(PROFILE_CH_FREQ_32bit_200002EC == 429550000)   {RF_ML7345_Init(Fre_429_550,0x15,28); T
             -IMER300ms = 100;}
 679   3                  ML7345_GPIO0RxDoneInt_Enable();
 680   3                  ML7345_SetAndGet_State(RX_ON);
 681   3                  CG2214M6_USE_R;
 682   3              }
 683   2              Flag_rx_pream = 1;
 684   2              ML7345_Write_Reg(ADDR_INT_SOURCE_GRP2,0x00); //清接收完成标志
 685   2          }
 686   1          
 687   1          if(reg == 0x01)
 688   1          {
 689   2              if(TIMER18ms < 50) TIMER18ms = 50;
 690   2              Flag_RxDone = 1;
 691   2              ML7345_Write_Reg(ADDR_INT_SOURCE_GRP2,0x00); //清接收完成标志
 692   2              //ML7345_StateFlag_Clear(RX_DONE_FLAG); //清除后接收的数据会被清0
 693   2          }
 694   1          
 695   1          reg = ML7345_Read_Reg(ADDR_INT_SOURCE_GRP3);
 696   1          if((reg & 0x01) && reg != 0xff)
 697   1          {
 698   2              Flag_TxDone = 1;
 699   2              Time_APP_blank_TX = 6;
 700   2              ML7345_StateFlag_Clear(TX_DONE_FLAG);
 701   2          }
 702   1      }
 703          
 704          void RX_ANALYSIS(void)
 705          {
 706   1          xdata u8 i;
 707   1          for (i = 0; i < 7; i++)
 708   1          {
 709   2              SPI_Receive_DataForC[i] = (u32)SPI_RECEIVE_BUFF[i * 4 + 3] |
 710   2                                        (u32)SPI_RECEIVE_BUFF[i * 4 + 2] << 8 |
C51 COMPILER V9.60.0.0   ML7345                                                            03/01/2022 16:31:55 PAGE 13  

 711   2                                        (u32)SPI_RECEIVE_BUFF[i * 4 + 1] << 16 |
 712   2                                        (u32)SPI_RECEIVE_BUFF[i * 4 + 0] << 24;
 713   2          }
 714   1              if(Flag_ERROR_Read==0)
 715   1              {
 716   2             FLAG_Receiver_IDCheck = 1;
 717   2             ID_Decode_IDCheck();
 718   2              }
 719   1      }
 720          
 721          void SCAN_RECEIVE_PACKET(void)
 722          {
 723   1          xdata short Cache;
 724   1          if(Flag_RxDone)
 725   1          {
 726   2              Flag_RxDone = 0;
 727   2              if(PROFILE_CH_FREQ_32bit_200002EC == 426075000)
 728   2              {
 729   3                  if(Flag_TX_ID_load == 1)    ML7345_ReadRx_Pack(SPI_RECEIVE_BUFF,24);
 730   3                  else                        ML7345_ReadRx_Pack(SPI_RECEIVE_BUFF,12);
 731   3              }
 732   2              else    ML7345_ReadRx_Pack(SPI_RECEIVE_BUFF,28);
 733   2              ML7345_StateFlag_Clear(RX_DONE_FLAG);
 734   2              RX_ANALYSIS();
 735   2              Flag_FREQ_Scan = 0;
 736   2      
 737   2              ML7345_SetAndGet_State(Force_TRX_OFF);
 738   2              Cache = ML7345_Read_Reg(ADDR_ED_RSLT);
 739   2              RAM_RSSI_SUM += Cache;
 740   2              RSSI_Read_Counter++;
 741   2              RAM_RSSI_AVG = RAM_RSSI_SUM / RSSI_Read_Counter;
 742   2              ML7345_Write_Reg(0x00,0x22);    // Bank1 Set
 743   2              ML7345_Write_Reg(0x2a,0x55);    //sync
 744   2              ML7345_Write_Reg(0x00,0x11);    // Bank0 Set
 745   2              ML7345_SetAndGet_State(RX_ON);
 746   2              CG2214M6_USE_R;
 747   2              Flag_rx_pream = 0;
 748   2              TIMER18ms = 28;
 749   2          }
 750   1      }
 751          /*
 752          void ML7345D_Error_Detect(void)
 753          {
 754              if(ML7345_Read_Reg(ADDR_INT_SOURCE_GRP1) & 0x04)    //PLL unlock interrupt
 755              {
 756                  ML7345_Write_Reg(ADDR_INT_SOURCE_GRP1,0xFB);
 757                  while(ML7345_SetAndGet_State(Get_Sta) != TRX_OFF);
 758                  ML7345_AutoTx_Data(CONST_TXPACKET_DATA_20000AF0,28);
 759              }
 760              else if(ML7345_Read_Reg(ADDR_INT_SOURCE_GRP3) & 0x10)    //TX FIFO access error interrupt
 761              {
 762                  ML7345_SetAndGet_State(Force_TRX_OFF);
 763                  ML7345_StateFlag_Clear(TX_DONE_FLAG);
 764                  ML7345_AutoTx_Data(CONST_TXPACKET_DATA_20000AF0,28);
 765              }
 766          }*/
 767          
 768          /*
 769          void TX_DataLoad(u32 IDCache, u8 CtrCmd, u8 *Packet)
 770          {
 771              xdata u8 i;
 772              xdata u16 CRCTemp = 0;
C51 COMPILER V9.60.0.0   ML7345                                                            03/01/2022 16:31:55 PAGE 14  

 773              CRCTemp = (IDCache & 0xffff) + (((IDCache >> 16) & 0xff) + ((u16)CtrCmd << 8));
 774              for (i = 0; i < 24; i++)
 775              {
 776                  *(Packet + (i / 4)) <<= 2;
 777                  *(Packet + (i / 4)) |= ((IDCache & ((u32)1 << i)) ? 2 : 1);
 778              }
 779              for (i = 24; i < 32; i++)
 780              {
 781                  *(Packet + (i / 4)) <<= 2;
 782                  *(Packet + (i / 4)) |= ((CtrCmd & ((u8)1 << (i - 24))) ? 2 : 1);
 783              }
 784              for (i = 32; i < 48; i++)
 785              {
 786                  *(Packet + (i / 4)) <<= 2;
 787                  *(Packet + (i / 4)) |= ((CRCTemp & ((u16)1 << (i - 32))) ? 2 : 1);
 788              }
 789              ClearWDT();
 790          }*/
 791          
 792          void TX_DataLoad_HighSpeed(u32 IDCache, Wireless_Body CtrCmd, u8 *Packet)
 793          {
 794   1          xdata u8 i;
 795   1          xdata u16 CRCTemp = 0;
 796   1      
 797   1          CRCTemp = (IDCache & 0xffff) + (((IDCache >> 16) & 0xff) + ((u16)CtrCmd.Fno_Type.byte << 8));
 798   1              for(i=0;i<4;i++)
 799   1                      CRCTemp+=CtrCmd.Data[i].ui;
 800   1      
 801   1          for (i = 0; i < 24; i++)
 802   1          {
 803   2              *(Packet + (i / 4)) <<= 2;
 804   2              *(Packet + (i / 4)) |= ((IDCache & ((u32)1 << i)) ? 2 : 1);
 805   2          }
 806   1          for (i = 24; i < 32; i++)
 807   1          {
 808   2              *(Packet + (i / 4)) <<= 2;
 809   2              *(Packet + (i / 4)) |= ((CtrCmd.Fno_Type.byte & ((u8)1 << (i - 24))) ? 2 : 1);
 810   2          }
 811   1              ClearWDT();
 812   1          for (i = 32; i < 48; i++)
 813   1          {
 814   2              *(Packet + (i / 4)) <<= 2;
 815   2              *(Packet + (i / 4)) |= ((CtrCmd.Data[0].ui & ((u16)1 << (i - 32))) ? 2 : 1);
 816   2          }
 817   1          for (i = 48; i < 64; i++)
 818   1          {
 819   2              *(Packet + (i / 4)) <<= 2;
 820   2              *(Packet + (i / 4)) |= ((CtrCmd.Data[1].ui & ((u16)1 << (i - 48))) ? 2 : 1);
 821   2          }
 822   1              ClearWDT();
 823   1          for (i = 64; i < 80; i++)
 824   1          {
 825   2              *(Packet + (i / 4)) <<= 2;
 826   2              *(Packet + (i / 4)) |= ((CtrCmd.Data[2].ui & ((u16)1 << (i - 64))) ? 2 : 1);
 827   2          }
 828   1          for (i = 80; i < 96; i++)
 829   1          {
 830   2              *(Packet + (i / 4)) <<= 2;
 831   2              *(Packet + (i / 4)) |= ((CtrCmd.Data[3].ui & ((u16)1 << (i - 80))) ? 2 : 1);
 832   2          }
 833   1          ClearWDT();
 834   1          for (i = 96; i < 112; i++)
C51 COMPILER V9.60.0.0   ML7345                                                            03/01/2022 16:31:55 PAGE 15  

 835   1          {
 836   2              *(Packet + (i / 4)) <<= 2;
 837   2              *(Packet + (i / 4)) |= ((CRCTemp & ((u16)1 << (i - 96))) ? 2 : 1);
 838   2          }
 839   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7023    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    133    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     25    ----
   IDATA SIZE       =      1    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
