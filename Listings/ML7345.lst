C51 COMPILER V9.60.0.0   ML7345                                                            04/15/2022 17:34:31 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE ML7345
OBJECT MODULE PLACED IN .\Objects\ML7345.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE user\src\ML7345.c OPTIMIZE(0,SPEED) BROWSE INCDIR(.\include;.\user\inc) 
                    -DEBUG OBJECTEXTEND PRINT(.\Listings\ML7345.lst) OBJECT(.\Objects\ML7345.obj)

line level    source

   1          #include "ML7345.h"
   2          
   3          //#include <stdlib.h>
   4          //#include <stdbool.h> /* For true/false definition                      */
   5          //#include <stdio.h>
   6          #include "spi.h"
   7          #include "gpio.h" // 芯片引脚定于
   8          #include "ram.h"
   9          #include "ID_Decode.h"
  10          #include "Type.h"
  11          #include "uart.h"
  12          
  13          //ROHM demo板 main fre=426.25;Vco Cal Range:425.85 - 431.85.MHz
  14          //TCXO = 24M
  15          xdata u8 Fre_426_075[8] = {0x23,0x08,0x19,0x99,0x23,0x07,0x91,0x11}; //426.075MHz频率设置
  16          xdata u8 Fre_429_350[8] = {0x23,0x0C,0x77,0x77,0x23,0x0B,0xEE,0xEF}; //429.350MHz频率设置
  17          xdata u8 Fre_429_550[8] = {0x23,0x0C,0xBB,0xBC,0x23,0x0C,0x33,0x33}; //429.550MHz频率设置
  18          xdata u8 Fre_426_750[8] = {0x23,0x09,0x00,0x00,0x23,0x08,0x77,0x77}; //426.750MHz频率设置
  19          xdata u8 Fre_429_175[8] = {0x23,0x0c,0x3b,0xbc,0x23,0x0b,0xb3,0x33}; //429.175MHz频率设置
  20          
  21          /**Receiver_vent**/ xdata u8 Receiver_vent_Cache = 0;
  22          xdata u32 SPI_Receive_DataForC[7]; //C郿
  23          xdata u8 SPI_RECEIVE_BUFF[40] = {0};
  24          
  25          /************Address: 0x20000500, Name: GENERIC_PKT_FRAME_CFG1***************************************/
  26          
  27          xdata u8 Radio_Date_Type = 1;
  28          xdata u8 tx_pack_cnt = 0;
  29          xdata u8 Radio_Date_Type_bak=1;
  30          xdata u8 APP_TX_freq=0;
  31          
  32          xdata u8 TX_Scan_step=0;
  33          xdata u8 First_TX_Scan=0;
  34          xdata u8 rf_offset = 0;
  35          
  36          xdata u8 Freq_SetBuff[8] = {0};
  37          /*
  38          Function: RF Init
  39          Parameter: Null
  40          Return: Null
  41          */
  42          /* Initialize: 426MHz General Packet(TCXO_ChStep=12.5kHz_DR=1.2kbps_Dev=0.6kHz_GFSK)
  43             发射功率0dBm */
  44          void RF_ML7345_Init(u8* freq,u8 sync,u8 rx_len)
  45          {
  46   1          ML7345_RESETN_SET();    /* Hardware Reset */
  47   1          while(1){
  48   2              if(ML7345_Read_Reg(0x0Du)&0x01u){   /* Wait Clock stabilization completion */
  49   3                  break;
  50   3              }
  51   2          }
  52   1          ML7345_Write_Reg(0x00,0x11);    /* Bank0 Set */
  53   1          ML7345_Write_Reg(0x01,0xff);    /* Software Reset */
  54   1          ML7345_Write_Reg(0x02,0x9f);    /* Clk Enable */
C51 COMPILER V9.60.0.0   ML7345                                                            04/15/2022 17:34:31 PAGE 2   

  55   1          ML7345_Write_Reg(0x03,0xc3);    /* TCXO_EN */
  56   1          ML7345_Write_Reg(0x04,0x03);    /* MSB first,Format D (non Wireless M-Bus, general purpose format) */
  57   1          ML7345_Write_Reg(0x05,0x10);    /* CRC Disable,Length field 1-byte mode */
  58   1          ML7345_Write_Reg(0x06,0x00);    /* Data Rate: 0x00 1.2kbps; 0x22 4.8kbps */
  59   1          ML7345_Write_Reg(0x07,0x15);    /* GFSK,NRZ */
  60   1          ML7345_Write_Reg(0x08,0x00);    /* Sync word pattern 1,Manchester Do not inverse polarity */
  61   1          ML7345_Write_Reg(0x09,0x00);    /* CH 0 */
  62   1          ML7345_Write_Reg(0x0a,0x18);    /* AUTO_TX_EN */
  63   1          ML7345_Write_Reg(0x0b,0x88);    /* TRX_OFF */
  64   1          ML7345_Write_Reg(0x0c,0x00);    /* FIFO mode */
  65   1          ML7345_Write_Reg(0x0d,0x08);    /* [INT_SOURCE_GRP1],Interrupt status for INT0 to INT7 */
  66   1          ML7345_Write_Reg(0x0e,0x00);    /* [INT_SOURCE_GRP2],Interrupt status for INT8 to INT15 (RX) */
  67   1          ML7345_Write_Reg(0x0f,0x00);    /* [INT_SOURCE_GRP3],Interrupt status for INT16 to INT23 (TX) */
  68   1          ML7345_Write_Reg(0x10,0x00);    /* masking interrupt,[INT_EN_GRP1]Interupt mask for INT0 to INT7 */
  69   1          ML7345_Write_Reg(0x11,0x00);    /* masking interrupt,[INT_EN_GRP2]Interupt mask for INT8 to INT15 */
  70   1          ML7345_Write_Reg(0x12,0x00);    /* masking interrupt,[INT_EN_GRP3]Interupt mask for INT16 to INT23 */
  71   1          ML7345_Write_Reg(0x13,0x00);    /* [CRC_ERR_H]CRC error status (high byte) */
  72   1          ML7345_Write_Reg(0x14,0x00);    /* [CRC_ERR_M]CRC error status (middle byte)*/
  73   1          ML7345_Write_Reg(0x15,0x00);    /* [CRC_ERR_L]CRC error status (low byte)*/
  74   1          ML7345_Write_Reg(0x16,0x00);    /* State clear control */
  75   1          ML7345_Write_Reg(0x17,0x00);    /* TX FIFO-Full level setting */
  76   1          ML7345_Write_Reg(0x18,0x00);    /* TX FIFO-Empty level setting and TX trigger level setting in FAST_TX
             - mode */
  77   1          ML7345_Write_Reg(0x19,0x00);    /* RX FIFO-Full level disable and level setting */
  78   1          ML7345_Write_Reg(0x1a,0x00);    /* RX FIFO-Empty level disable and level setting (high byte) */
  79   1      
  80   1          ML7345_Write_Reg(0x2d,0x06);    /* SLEEP execution and Wake-up operation setting */
  81   1          /* Preamble */
  82   1          ML7345_Write_Reg(0x3f,0x05);    /* Preamble pattern setting,p198*/
  83   1      
  84   1          ML7345_Write_Reg(0x41,0x8B);    /* Enable ED value calculation,bit3=0 ED value constantly updated,bit3
             -=1 ED value acquired at SyncWord detection timing*/
  85   1      
  86   1          ML7345_Write_Reg(0x42,0x00);    //TX前导码长度高八位
  87   1          ML7345_Write_Reg(0x43,0x34);    //TX前导码长度低八位,不等少于16个位,TX preamble length =
             - (specified value x2) bits
  88   1          //----------------------------------------------------------------------------------------------------
             --
  89   1          ML7345_Write_Reg(0x45,0x08);    //接收前导码长度(bit) RX preamble setting and ED threshold chec
             -k setting
  90   1          //----------------------------------------------------------------------------------------------------
             --
  91   1          ML7345_Write_Reg(0x4e,0x07);    /* GPIO0 [output] interrupt notification signal (SINTN) */
  92   1          ML7345_Write_Reg(0x4f,0x00);    /* GPIO1 [output] “L” level,Upon reset,disable GPIO1 pin is CLK_OU
             -T function */
  93   1          ML7345_Write_Reg(0x50,0x00);    /* GPIO2 [output] “L” level */
  94   1          ML7345_Write_Reg(0x51,0x00);    /* GPIO3 [output] “L” level */
  95   1      
  96   1          ML7345_Write_Reg(0x54,0x14);    /* Channel filter bandwidth setting */
  97   1      
  98   1          ML7345_Write_Reg(0x60,0x06); /* Decimation gain setting 提高灵敏度 */
  99   1      
 100   1          ML7345_Write_Reg(0x63,0x88);    /* Fine adjustment of load capacitance for oscillation circuits */
 101   1      
 102   1          ML7345_Write_Reg(0x67,0x16);    /* 功率设置12dbm */
 103   1          ML7345_Write_Reg(0x68,0x10);    /* PA regulator fine adjustment */
 104   1          ML7345_Write_Reg(0x69,0x03);    /* PA gain adjustment */
 105   1      
 106   1          ML7345_Write_Reg(0x6e,0x5b);    /*5b VCO calibration setting or status indication */
 107   1      
 108   1          ML7345_Write_Reg(0x7a,0x00);    //发送包长度高八位
 109   1          ML7345_Write_Reg(0x7b,0x0c);    //发送包长度低八位
C51 COMPILER V9.60.0.0   ML7345                                                            04/15/2022 17:34:31 PAGE 3   

 110   1      
 111   1          ML7345_Write_Reg(0x7d,0x00);    //接收包长度高八位
 112   1          ML7345_Write_Reg(0x7e,rx_len);    //接收包长度低八位
 113   1      
 114   1          /***************************************************************************************************/
 115   1      
 116   1          ML7345_Write_Reg(0x00,0x22);    /* Bank1 Set */
 117   1          ML7345_Write_Reg(0x02,0x07);    /* TX data rate conversion setting (high 4bits) */
 118   1          ML7345_Write_Reg(0x03,0xd0);    /* TX data rate conversion setting (low byte) */
 119   1          ML7345_Write_Reg(0x04,0x00);    /* RX data rate concversion setting 1 (high 4bits) */
 120   1          ML7345_Write_Reg(0x05,0x50);    /* RX data rate cnvesrion setting 1 (low byte) */
 121   1      
 122   1          ML7345_Write_Reg(0x11,0x27);    /* RSSI offset value setting during low gain operation */
 123   1      
 124   1          ML7345_Write_Reg(0x13,0x0c);    /* Scale factor setting for ED value conversion */
 125   1      
 126   1          ML7345_Write_Reg(0x1a,0x02);    /* Divide 2,PLL frequency division setting */
 127   1          /* 426.075MHz */
 128   1          ML7345_Write_Reg(0x1b,freq[0]);    /* TX frequency setting (I counter),p67-69 */
 129   1          ML7345_Write_Reg(0x1c,freq[1]);    /* TX frequency setting (F counter high 4bit) */
 130   1          ML7345_Write_Reg(0x1d,freq[2]);    /* TX frequency setting (F counter middle byte) */
 131   1          ML7345_Write_Reg(0x1e,freq[3]);    /* TX frequency setting (F counter low byte) */
 132   1          ML7345_Write_Reg(0x1f,freq[0]);    /* RX frequency setting (I counter) */
 133   1          ML7345_Write_Reg(0x20,freq[1]);    /* RX frequency setting (F counter high 4bit)  */
 134   1          ML7345_Write_Reg(0x21,freq[2]);    /* RX frequency setting (F counter middle byte) */
 135   1          ML7345_Write_Reg(0x22,freq[3]);    /* RX frequency setting (F counter low byte) */
 136   1      
 137   1          ML7345_Write_Reg(0x23,0x08);    /* 25KHz,Channel space setting (high byte) */
 138   1          ML7345_Write_Reg(0x24,0x88);    /* Channel space setting (low byte) */
 139   1          /* SyncWord 0x00005515 */
 140   1          ML7345_Write_Reg(0x25,0x08);    /* SyncWord length setting */
 141   1          ML7345_Write_Reg(0x26,0x0f);    /* SyncWord enable setting */
 142   1          ML7345_Write_Reg(0x27,0x00);    /* SyncWord #1 setting (bit24 to 31) */
 143   1          ML7345_Write_Reg(0x28,0x00);    /* SyncWord #1 setting (bit16 to 23) */
 144   1          ML7345_Write_Reg(0x29,0x00);    /* SyncWord #1 setting (bit8 to 15) */
 145   1          ML7345_Write_Reg(0x2a,sync);    /* SyncWord #1 setting (bit0 to 7) */
 146   1      
 147   1          ML7345_Write_Reg(0x2f,0x08);    /* GFSK clock setting x8 clock,GFSK/FSK modulation timing resolution s
             -etting */
 148   1          ML7345_Write_Reg(0x30,0x00);    /* GFSK frequency deviation setting (high 6bits) */
 149   1          ML7345_Write_Reg(0x31,0xAE);    /* P71  GFSK frequency deviation:2.0KHz,GFSK frequency deviation setti
             -ng (low byte) */
 150   1      
 151   1          /*(Channel#0 frequency-400khz)426.075:0x23 0x07 0x91 0x11;
 152   1          426.25:0x23 0x07 0xcc 0xcc */
 153   1          ML7345_Write_Reg(0x4d,freq[4]);    /* VCO calibration low limit frequency setting (I counter),p254 */
 154   1          ML7345_Write_Reg(0x4e,freq[5]);    /* VCO calibration low limit frequency setting (F counter high 4bit
             -s) */
 155   1          ML7345_Write_Reg(0x4f,freq[6]);    /* VCO calibration low limit frequency setting (F counter middle by
             -te) */
 156   1          ML7345_Write_Reg(0x50,freq[7]);    /* VCO calibration low limit frequency setting (F counter low byte)
             - */
 157   1          ML7345_Write_Reg(0x51,0x04);    /* 6 MHz,VCO calibration upper limit frequency setting */
 158   1          ML7345_Write_Reg(0x52,0x5a);    /* VCO calibration low limit value indication and setting */
 159   1          ML7345_Write_Reg(0x53,0x66);    /* VCO calibration upper limit value indication and setting */
 160   1      
 161   1          ML7345_Write_Reg(0x5c,0x15);    /* 0x10 Demodulator configulation 6 */
 162   1          ML7345_Write_Reg(0x5d,0x1b);    /* 0x1b Demodulator configulation 7 */
 163   1          ML7345_Write_Reg(0x5e,0x05);    /* 0x05 Demodulator configuration 8 */
 164   1          ML7345_Write_Reg(0x5f,0x67);    /* 0x67 Demodulator configulation 9 */
 165   1          ML7345_Write_Reg(0x60,0x0c);    /* Demodulator configulation 10 */
 166   1      
C51 COMPILER V9.60.0.0   ML7345                                                            04/15/2022 17:34:31 PAGE 4   

 167   1          SetReg_Rssi();  //2021.11.17 ROHM提出必要设置,否则读取RSSI偏差大。
 168   1      
 169   1          ML7345_Write_Reg(0x00,0x44); //bank2
 170   1          ML7345_Write_Reg(0x2a,0x0f); //2019.11.25 ROHM提出设置,设置之后灵敏度提升了2dBm
 171   1      
 172   1          /* 以下寄存器值为发送功率必要设置，不然发送功率偏差大 */
 173   1          ML7345_Write_Reg(0x00,0x44); //bank2
 174   1          ML7345_Write_Reg(0x4f,0x00);
 175   1      
 176   1          ML7345_Write_Reg(0x00,0x88); //bank3
 177   1          ML7345_Write_Reg(0x2f,0x3f);
 178   1          ML7345_Write_Reg(0x0c,0x41);
 179   1          ML7345_Write_Reg(0x0d,0x33);
 180   1          ML7345_Write_Reg(0x0e,0x54);
 181   1          ML7345_Write_Reg(0x14,0x10);
 182   1          ML7345_Write_Reg(0x24,0x03);
 183   1          ML7345_Write_Reg(0x7e,0x00);
 184   1      
 185   1          if((PROFILE_CH_FREQ_32bit_200002EC == 429350000) || (PROFILE_CH_FREQ_32bit_200002EC == 429550000)) ML7
             -345_DataRate_Set_4_8k();
 186   1          else    ML7345_DataRate_Set_1_2k();
 187   1          /*****************************************************/
 188   1      
 189   1          ML7345_Write_Reg(0x00, 0x11);     /* BANK_SEL(BANK0) */
 190   1          ML7345_Write_Reg(0x6f, 0x01);     /* VCO_CAL_START(CAL start) */
 191   1          while(1){
 192   2              if(ML7345_Read_Reg(0x0Du)&0x02u){   /* Wait VCO calibration completion */
 193   3                  break;
 194   3              }
 195   2          }
 196   1          ML7345_AllStateFlag_Clear(); //清除所有标志
 197   1      }
 198          
 199          void ML7345_MeasurBER_Init(void)
 200          {
 201   1          ML7345_Write_Reg(ADDR_BANK_SEL,BANK1_SEL);
 202   1          ML7345_Write_Reg(0x0e,0x00);
 203   1      
 204   1          ML7345_Write_Reg(ADDR_BANK_SEL,BANK3_SEL);
 205   1          ML7345_Write_Reg(0x0d,0x33);
 206   1      
 207   1          ML7345_Write_Reg(ADDR_BANK_SEL,BANK0_SEL);
 208   1          ML7345_Write_Reg(0x0c,0x40); //50   /* DIO_SET, continuous output mode,DCLK is constantly output,no OU
             -TPUT (NOT stop output)*/
 209   1          ML7345_Write_Reg(0x4d,0x80); //80
 210   1      
 211   1          ML7345_Write_Reg(0x4E,0x05);    //ML7345D GPIO0 DCLK
 212   1          ML7345_Write_Reg(0x51,0x04);    //ML7345D GPIO3 DIO
 213   1      }
 214          
 215          
 216          void DataReceive(void)
 217          {
 218   1          static u8 StateCache = 0;
 219   1          static u8 Cache = 0;
 220   1          static u8 X_HISbyte = 0;
 221   1          switch (StateCache)
 222   1          {
 223   2              case 0:
 224   2              {
 225   3                  Cache <<= 1;
 226   3                  if (ML7345_DATA)
C51 COMPILER V9.60.0.0   ML7345                                                            04/15/2022 17:34:31 PAGE 5   

 227   3                      Cache++;
 228   3                  if (Cache == 0x55)
 229   3                  {
 230   4                      StateCache = 1;
 231   4                      X_HISbyte = 0;
 232   4                      Cache = 0;
 233   4                  }
 234   3              }
 235   2              break;
 236   2              case 1:
 237   2              {
 238   3                  if (ML7345_DATA != X_HISbyte)
 239   3                      X_ERR++;
 240   3                  X_COUNT++;
 241   3                  X_HISbyte ^= 1;
 242   3                  if (X_COUNT >= 1000)
 243   3                      StateCache = 2;
 244   3              }
 245   2              break;
 246   2              case 2:
 247   2                  if (X_COUNT == 0)
 248   2                      StateCache = 0;
 249   2                  break;
 250   2              default:
 251   2                  break;
 252   2          }
 253   1      }
 254          
 255          
 256          
 257          void Tx_Data_Test(u8 mode)
 258          {
 259   1          ML7345_Write_Reg(0x00, 0x11);     /* BANK_SEL(BANK0) */
 260   1          switch(mode)
 261   1          {
 262   2              /* 发送：载波 */
 263   2              case 0: ML7345_Write_Reg(ADDR_RF_TEST_MODE,0x21);break;
 264   2      
 265   2              /* 发送：0101 */
 266   2              case 1:ML7345_Write_Reg(ADDR_RF_TEST_MODE,0x11);break;
 267   2      
 268   2              /* 发送：0 */
 269   2              case 2:ML7345_Write_Reg(ADDR_RF_TEST_MODE,0x09);break;
 270   2      
 271   2              /* 发送：1 */
 272   2              case 3: ML7345_Write_Reg(ADDR_RF_TEST_MODE,0x05);break;
 273   2      
 274   2               /* 发送：随机 */
 275   2              default:
 276   2                  ML7345_Write_Reg(ADDR_RF_TEST_MODE,0x03);
 277   2               break;
 278   2          }
 279   1          ML7345_SetAndGet_State(TX_ON);
 280   1      }
 281          
 282          
 283          void RF_Ber_Test(void)
 284          {
 285   1          if (X_COUNT >= 1000)
 286   1          {
 287   2              if (X_ERR >= 50) Receiver_LED_RX = 0;
 288   2              else             Receiver_LED_RX = 1;
C51 COMPILER V9.60.0.0   ML7345                                                            04/15/2022 17:34:31 PAGE 6   

 289   2              X_ERR = 0;
 290   2              X_COUNT = 0;
 291   2              X_ERRTimer = 1250;
 292   2          }
 293   1          if (X_ERRTimer == 0)
 294   1              Receiver_LED_RX = 0;
 295   1      }
 296          
 297          void Uart_RF_Ber_Test(void)
 298          {
 299   1          if (X_COUNT >= 1000)
 300   1          {
 301   2              if(X_ERR > 255)  X_ERR_CNT = 255;
 302   2              else X_ERR_CNT = X_ERR;
 303   2      
 304   2              if (X_ERR >= 50) Receiver_LED_RX = 0;
 305   2              else             Receiver_LED_RX = 1;
 306   2      
 307   2              X_ERR = 0;
 308   2              X_COUNT = 0;
 309   2              X_ERRTimer = 1250;
 310   2          }
 311   1          if (X_ERRTimer == 0)
 312   1              Receiver_LED_RX = 0;
 313   1      }
 314          
 315          void APP_TX_PACKET(void)
 316          {
 317   1           xdata char rssi;
 318   1               xdata u8 i=2,j=0;
 319   1      
 320   1               if((TP3==0)&&(FLAG_Key_TP3==0))FLAG_Key_TP3=1;
 321   1      
 322   1            if((Time_error_read_timeout==0)&&(Flag_ERROR_Read==1))
 323   1            {
 324   2                      Flag_ERROR_Read=0;
 325   2                      FLAG_APP_TX_fromUART_err_read=0;
 326   2            }
 327   1            if( (Flag_FREQ_Scan==0) && ((PROFILE_CH_FREQ_32bit_200002EC == 429350000)||(PROFILE_CH_FREQ_32bit_20
             -0002EC == 429550000)) &&
 328   1                        ((FLAG_APP_TX_fromUART_err_read==1) && (Flag_ERROR_Read==1) && (Time_error_read_gap==0) && ((FLAG_AP
             -P_RX==1)||(FLAG_APP_RXstart==1)) && (Radio_Date_Type_bak==2))
 329   1                         )
 330   1            {
 331   2               for(j=0;j<8;j++)Last_Uart_Struct_DATA_Packet_Contro.Data[j/2].uc[j%2]=0x00;
 332   2      
 333   2               Last_Uart_Struct_DATA_Packet_Contro.Fno_Type.UN.type=0x1f;
 334   2                       Last_Uart_Struct_DATA_Packet_Contro.Data[0].uc[0]=0x98;
 335   2                       ERROR_Read_sendTX_packet++;
 336   2                       Last_Uart_Struct_DATA_Packet_Contro.Data[0].uc[1]=ERROR_Read_sendTX_packet;
 337   2                       while(ERROR_Read_sendTX_count<UART_DATA_ID98[1]-4)
 338   2                       {
 339   3                           Last_Uart_Struct_DATA_Packet_Contro.Data[i/2].uc[i%2]=UART_DATA_ID98[ERROR_Read_sendTX_count+4];
 340   3                               ERROR_Read_sendTX_count++;
 341   3                               i++;
 342   3                               if(i==8)break;
 343   3                       }
 344   2                       if(ERROR_Read_sendTX_count==UART_DATA_ID98[1]-4)
 345   2                       {
 346   3                              Last_Uart_Struct_DATA_Packet_Contro.Data[0].uc[1]= Last_Uart_Struct_DATA_Packet_Contro.Data[0].uc[1] |
             -0x80;
 347   3                              FLAG_APP_TX_fromUART_err_read=0;
C51 COMPILER V9.60.0.0   ML7345                                                            04/15/2022 17:34:31 PAGE 7   

 348   3                              Flag_ERROR_Read=0;
 349   3                       }
 350   2      
 351   2                       DEF_APP_TX_freq=3;
 352   2                       FLAG_APP_TX=1;
 353   2                       FLAG_APP_RX=0;
 354   2                       //FLAG_APP_RXstart=0;
 355   2                       APP_TX_freq=0;
 356   2                       TX_Scan_step=1;
 357   2                       First_TX_Scan=0;
 358   2      
 359   2                }
 360   1            else if((Flag_FREQ_Scan==0)&&((PROFILE_CH_FREQ_32bit_200002EC == 429350000)||(PROFILE_CH_FREQ_32bit_
             -200002EC == 429550000))&&
 361   1                        (((FLAG_APP_TX_fromOUT==1)&&(TIME_APP_TX_fromOUT==0))||(FLAG_Key_TP3==1)||
 362   1                         //((FLAG_APP_TX_fromUART==1)&&(((TIME_APP_TX_fromOUT==0)&&(Radio_Date_Type_bak==2))||((TIMER300ms==
             -0)&&(Radio_Date_Type_bak==1)))&&(Uart_Struct_DATA_Packet_Contro.data[0].ui!=Last_Uart_Struct_DATA_Packet_Contro.data[0].
             -ui))
 363   1                         ((FLAG_APP_TX_fromUART==1)&&(((TIME_APP_TX_fromOUT==0)&&(Radio_Date_Type_bak==2))||((TIMER300ms==0)
             -&&(Radio_Date_Type_bak==1))))
 364   1                        )
 365   1                      )
 366   1                {
 367   2                                                FLAG_APP_TX_fromUART=0;
 368   2                                                FLAG_Key_TP3=0;
 369   2                                                Last_Uart_Struct_DATA_Packet_Contro=Uart_Struct_DATA_Packet_Contro;
 370   2                                                Last_Uart_Struct_DATA_Packet_Contro.Fno_Type.UN.type=1;
 371   2                                                rssi=(RAM_RSSI_AVG - 255)/3 - 51;
 372   2                            rssi = -rssi;
 373   2                                                if(Radio_Date_Type_bak==2)rssi= rssi | 0x80;
 374   2                                                Last_Uart_Struct_DATA_Packet_Contro.Data[1].uc[0]= rssi;
 375   2                                                if(FLAG_APP_TX_fromOUT==1) Last_Uart_Struct_DATA_Packet_Contro.Fno_Type.UN.fno= Struct_DATA_Packet_
             -Contro_fno;
 376   2                                                FLAG_APP_TX_fromOUT=0;
 377   2                                                TIME_APP_TX_fromOUT=0;
 378   2      
 379   2                                                DEF_APP_TX_freq=3;
 380   2                                                FLAG_APP_TX=1;
 381   2                                                FLAG_APP_RX=0;
 382   2                                                APP_TX_freq=0;
 383   2                                                TX_Scan_step=1;
 384   2                                                First_TX_Scan=0;
 385   2      
 386   2                            RSSI_Read_Counter = 0;
 387   2                            RAM_RSSI_SUM = 0;
 388   2                }
 389   1          if(FLAG_APP_TX == 1)
 390   1          {
 391   2              if(TX_Scan_step==1)TX_Scan_step=2;
 392   2                         if(TX_Scan_step==2)
 393   2                         {
 394   3                                      if(APP_TX_freq==0)
 395   3                                      {
 396   4                          Flag_tx_en = 1;
 397   4                          TIMER18ms = 300;
 398   4                                          Receiver_LED_TX = 1;
 399   4                                              TX_DataLoad_HighSpeed(ID_SCX1801_DATA,Last_Uart_Struct_DATA_Packet_Contro, &CONST_TXPACKET_DATA_20000
             -AF0[0]);
 400   4                          ML7345_SetAndGet_State(Force_TRX_OFF);
 401   4                          ML7345_Write_Reg(0x00,0x22);    // Bank1 Set
 402   4                          ML7345_Write_Reg(0x2a,0x15);    //sync
 403   4                          ML7345_Write_Reg(ADDR_BANK_SEL,BANK0_SEL);
C51 COMPILER V9.60.0.0   ML7345                                                            04/15/2022 17:34:31 PAGE 8   

 404   4                          ML7345_GPIO0TxDoneInt_Enable();
 405   4                          ML7345_AutoTx_Data(CONST_TXPACKET_DATA_20000AF0,28);
 406   4                          Time_Tx_Out = 100;
 407   4                                              APP_TX_freq=1; //1
 408   4                                      }
 409   3                                      else if((APP_TX_freq < DEF_APP_TX_freq) && (Flag_TxDone == 1) && (Time_APP_blank_TX == 0))
 410   3                                      {
 411   4                          Flag_TxDone = 0;
 412   4                          ML7345_AutoTx_Data(CONST_TXPACKET_DATA_20000AF0,28);
 413   4                          Time_Tx_Out = 100;
 414   4                                              APP_TX_freq++;
 415   4                                      }
 416   3                                      else if((APP_TX_freq == DEF_APP_TX_freq) && (Flag_TxDone == 1) && (Time_APP_blank_TX == 0))
 417   3                                      {
 418   4                          Flag_TxDone = 0;
 419   4                          APP_TX_freq++;
 420   4                          FLAG_APP_RXstart=1;
 421   4                          FLAG_APP_TX=0;
 422   4                          Time_APP_RXstart=1;
 423   4                          Receiver_LED_TX = 0;
 424   4                          FLAG_APP_TX_once=0;
 425   4                          Flag_tx_en = 0;
 426   4                          retx_cnt = 0;
 427   4                                      }
 428   3                         }
 429   2          }
 430   1          if((FLAG_APP_RXstart==1)&&(Time_APP_RXstart==0)&&(FLAG_APP_TX_fromUART_err_read==0))
 431   1          {
 432   2              FLAG_APP_RXstart = 0;
 433   2              FLAG_APP_RX = 1;
 434   2          }
 435   1          else if(Flag_tx_en == 1 && Time_Tx_Out == 0 && Flag_TxDone == 0 && FLAG_APP_RXstart == 0)
 436   1          {
 437   2              if(PROFILE_CH_FREQ_32bit_200002EC == 429350000) RF_ML7345_Init(Fre_429_350,0x15,28);
 438   2              else if(PROFILE_CH_FREQ_32bit_200002EC == 429550000) RF_ML7345_Init(Fre_429_550,0x15,28);
 439   2              ML7345_GPIO0TxDoneInt_Enable();
 440   2              ML7345_GPIO0RxDoneInt_Enable();
 441   2              ML7345_AutoTx_Data(CONST_TXPACKET_DATA_20000AF0,28);
 442   2              Time_Tx_Out = 100;
 443   2              retx_cnt++;
 444   2              if(retx_cnt >= 3)
 445   2              {
 446   3                  retx_cnt = 0;
 447   3                  Flag_tx_en = 0;
 448   3                  FLAG_APP_RX = 1;
 449   3                  Receiver_LED_TX = 0;
 450   3              }
 451   2          }
 452   1      }
 453          
 454          //--------------------------------------------------------------------------------------------------
 455          void ML7345D_RF_test_mode(void)
 456          {
 457   1          Receiver_LED_OUT = 1;
 458   1          Flag_test_mode = 0;
 459   1          Flag_test_pc = 0;
 460   1          while (Receiver_test == 0)
 461   1          {
 462   2              if(Flag_test_mode == 0)
 463   2              {
 464   3                  Init_Uart0_T1();
 465   3                  Receiver_LED_OUT = 0;
C51 COMPILER V9.60.0.0   ML7345                                                            04/15/2022 17:34:31 PAGE 9   

 466   3                  BEEP_Module(500,1);
 467   3              }
 468   2              Flag_test_mode = 1;
 469   2              ClearWDT();   // Service the WDT
 470   2              if(Flag_test_pc == 0)
 471   2              {
 472   3                  if (TP4 == 0) //test  TX
 473   3                  {
 474   4                      if (TP3 == 0)
 475   4                          Tx_Rx_mode = 0;
 476   4                      else
 477   4                          Tx_Rx_mode = 1;
 478   4                  }
 479   3                  else //test  RX
 480   3                  {
 481   4                      if (TP3 == 0)
 482   4                          Tx_Rx_mode = 2;
 483   4                      else
 484   4                          Tx_Rx_mode = 3;
 485   4                  }
 486   3                  if ((Tx_Rx_mode == 0) || (Tx_Rx_mode == 1))
 487   3                  {
 488   4                      CG2214M6_USE_T;
 489   4                      FG_test_rx = 0;
 490   4                      Receiver_LED_RX = 0;
 491   4                      FG_test_tx_off = 0;
 492   4                      Flag_test_rssi = 0;
 493   4                      PROFILE_CH_FREQ_32bit_200002EC = 429175000;
 494   4                      if (Tx_Rx_mode == 0) //发载波，无调制信叿
 495   4                      {
 496   5                          Receiver_LED_TX = 1;
 497   5                          FG_test_mode = 0;
 498   5                          FG_test_tx_1010 = 0;
 499   5                          if (FG_test_tx_on == 0)
 500   5                          {
 501   6                              FG_test_tx_on = 1;
 502   6                              ML7345_SetAndGet_State(Force_TRX_OFF);
 503   6                              ML7345_Frequency_Set(Fre_429_175,1);
 504   6                              Tx_Data_Test(0);
 505   6                          }
 506   5                      }
 507   4                      else //发载波，有调制信叿
 508   4                      {
 509   5                          if (TIMER1s == 0)
 510   5                          {
 511   6                              TIMER1s = 500;
 512   6                              Receiver_LED_TX = !Receiver_LED_TX;
 513   6                          }
 514   5                          FG_test_mode = 1;
 515   5                          FG_test_tx_on = 0;
 516   5                          if (FG_test_tx_1010 == 0)
 517   5                          {
 518   6                              FG_test_tx_1010 = 1;
 519   6                              ML7345_SetAndGet_State(Force_TRX_OFF);
 520   6                              ML7345_Frequency_Set(Fre_429_175,1);
 521   6                              Tx_Data_Test(1);
 522   6                          }
 523   5                      }
 524   4                  }
 525   3                  //else  {           //test  RX
 526   3                  if ((Tx_Rx_mode == 2) || (Tx_Rx_mode == 3))
 527   3                  {
C51 COMPILER V9.60.0.0   ML7345                                                            04/15/2022 17:34:31 PAGE 10  

 528   4                      CG2214M6_USE_R;
 529   4                      FG_test_rx = 1;
 530   4                      Receiver_LED_TX = 0;
 531   4                      FG_test_mode = 0;
 532   4                      FG_test_tx_on = 0;
 533   4                      FG_test_tx_1010 = 0;
 534   4                      if (FG_test_tx_off == 0)
 535   4                      {
 536   5                          FG_test_tx_off = 1;
 537   5                          ML7345_SetAndGet_State(Force_TRX_OFF);
 538   5                          PROFILE_CH_FREQ_32bit_200002EC = 426750000;
 539   5                          ML7345_Frequency_Set(Fre_426_750,1);
 540   5                          ML7345_MeasurBER_Init();
 541   5                          ML7345_SetAndGet_State(RX_ON);
 542   5                      }
 543   4                      if (Tx_Rx_mode == 2) //packet usart out put RSSI
 544   4                      {
 545   5                          if (TIMER1s == 0)
 546   5                          {
 547   6                              TIMER1s = 500;
 548   6                              Receiver_LED_RX = !Receiver_LED_RX;
 549   6                          }
 550   5                          //SCAN_RECEIVE_PACKET(); //扫描接收数据
 551   5                      }
 552   4                      if (Tx_Rx_mode == 3) //packet usart out put BER
 553   4                      {
 554   5                          RF_Ber_Test();
 555   5                      }
 556   4                  }
 557   3              }
 558   2              PC_PRG();
 559   2          }
 560   1          if(Flag_test_mode == 1)
 561   1          {
 562   2              //UART1_INIT();
 563   2              ML7345_SetAndGet_State(Force_TRX_OFF);
 564   2              RF_ML7345_Init(Fre_426_075,0x55,12);
 565   2          }
 566   1          PROFILE_CH_FREQ_32bit_200002EC = 426075000;
 567   1      
 568   1          Flag_test_mode = 0;
 569   1          Flag_test_pc = 0;
 570   1          ML7345_GPIO0RxDoneInt_Enable(); /* 开启接收完成中断,ML7345D GPIO0中断输出 */
 571   1          ML7345_GPIO0TxDoneInt_Enable(); /* 开启发送完成中断,ML7345D GPIO0中断输出 */
 572   1          FG_test_rx = 0;
 573   1          TIMER1s = 0;
 574   1          Receiver_LED_TX = 0;
 575   1          Receiver_LED_RX = 0;
 576   1          FG_Receiver_LED_RX = 0;
 577   1          //Receiver_LED_OUT = 0;
 578   1          Time_rf_init = 1000;
 579   1          FLAG_APP_RX = 1;
 580   1      }
 581          
 582          void ML7345d_Change_Channel(void)
 583          {
 584   1          if ((FLAG_ID_Erase_Login == 1) || (FLAG_ID_Login == 1) ||(FLAG_ID_SCX1801_Login==1))
 585   1          {
 586   2              PROFILE_CH_FREQ_32bit_200002EC = 426075000;
 587   2              Radio_Date_Type=1;
 588   2              Channels=1;
 589   2              ML7345_Frequency_Set(Fre_426_075,Radio_Date_Type);
C51 COMPILER V9.60.0.0   ML7345                                                            04/15/2022 17:34:31 PAGE 11  

 590   2          }
 591   1          else
 592   1          {
 593   2              switch(Channels)
 594   2              {
 595   3                  case 1:
 596   3                          Radio_Date_Type = 1;
 597   3                          PROFILE_CH_FREQ_32bit_200002EC = 426075000;
 598   3                          ML7345_Frequency_Set(Fre_426_075,Radio_Date_Type);       //加上VCO校准后用时5ms
             -，不加1.2ms
 599   3                          if(ID_SCX1801_DATA == 0) Channels = 1;
 600   3                          else Channels = 2;
 601   3                          break;
 602   3      
 603   3                  case 2:
 604   3                          Radio_Date_Type = 2;
 605   3                          PROFILE_CH_FREQ_32bit_200002EC = 429350000;
 606   3                          ML7345_Frequency_Set(Fre_429_350,Radio_Date_Type);
 607   3                          Channels = 3;
 608   3                          break;
 609   3      
 610   3                  case 3:
 611   3                          Radio_Date_Type = 2;
 612   3                          PROFILE_CH_FREQ_32bit_200002EC = 429550000;
 613   3                          ML7345_Frequency_Set(Fre_429_550,Radio_Date_Type);
 614   3                          Channels = 4;
 615   3                          break;
 616   3      
 617   3                   case 4:
 618   3                          Radio_Date_Type = 1;
 619   3                          PROFILE_CH_FREQ_32bit_200002EC = 426075000;
 620   3                          ML7345_Frequency_Set(Fre_426_075,Radio_Date_Type);
 621   3                          Channels = 1;
 622   3                          break;
 623   3      
 624   3                   default:
 625   3                      break;
 626   3              }
 627   2          }
 628   1      }
 629          
 630          void ML7345D_Freq_Scanning(void)
 631          {
 632   1          if(TIMER18ms == 0)
 633   1          {
 634   2              if(Flag_FREQ_Scan)  return;
 635   2              ML7345d_Change_Channel();
 636   2              if(Time_rf_init == 0)
 637   2              {
 638   3                  Time_rf_init = 1000;
 639   3                  if(PROFILE_CH_FREQ_32bit_200002EC == 426075000) RF_ML7345_Init(Fre_426_075,0x55,12);
 640   3                  else if(PROFILE_CH_FREQ_32bit_200002EC == 429350000) RF_ML7345_Init(Fre_429_350,0x55,28);
 641   3                  else if(PROFILE_CH_FREQ_32bit_200002EC == 429550000) RF_ML7345_Init(Fre_429_550,0x55,28);
 642   3                  ML7345_GPIO0RxDoneInt_Enable();
 643   3              }
 644   2              ML7345_SetAndGet_State(RX_ON);
 645   2              CG2214M6_USE_R;
 646   2      
 647   2              if(Radio_Date_Type==1)
 648   2                  TIMER18ms = 18;
 649   2              else if(Radio_Date_Type > 1)
 650   2                  TIMER18ms = 18;
C51 COMPILER V9.60.0.0   ML7345                                                            04/15/2022 17:34:31 PAGE 12  

 651   2              Flag_rx_pream = 0;
 652   2              Flag_tx_en = 0;
 653   2              RSSI_Read_Counter = 0;
 654   2              RAM_RSSI_SUM = 0;
 655   2      
 656   2          }else Flag_FREQ_Scan = 0;
 657   1      }
 658          
 659          //idata u8 red = 0;
 660          void ML7345_TRX_Del(void)
 661          {
 662   1          idata u8 reg = 0;
 663   1          if(Flag_tx_en == 0) reg = RF_SyncWord_DONE();
 664   1      
 665   1          if(reg == 0x20)
 666   1          {
 667   2              TIMER18ms = 550;
 668   2              Flag_FREQ_Scan = 1;
 669   2              if(Flag_rx_pream == 0 && Flag_set_freq == 0)
 670   2              {
 671   3                  FG_Receiver_LED_RX = 1;
 672   3                  ML7345_SetAndGet_State(Force_TRX_OFF);
 673   3                  if(PROFILE_CH_FREQ_32bit_200002EC == 426075000)
 674   3                  {
 675   4                      TIMER300ms = 600;
 676   4                      if(Flag_TX_ID_load == 0)    RF_ML7345_Init(Fre_426_075,0x15,12);
 677   4                      else                        RF_ML7345_Init(Fre_426_075,0x15,24);
 678   4                  }
 679   3                  else if(PROFILE_CH_FREQ_32bit_200002EC == 429350000)   {RF_ML7345_Init(Fre_429_350,0x15,28); T
             -IMER300ms = 100;}
 680   3                  else if(PROFILE_CH_FREQ_32bit_200002EC == 429550000)   {RF_ML7345_Init(Fre_429_550,0x15,28); T
             -IMER300ms = 100;}
 681   3                  ML7345_GPIO0RxDoneInt_Enable();
 682   3                  ML7345_SetAndGet_State(RX_ON);
 683   3                  CG2214M6_USE_R;
 684   3              }
 685   2              Flag_rx_pream = 1;
 686   2              ML7345_Write_Reg(ADDR_INT_SOURCE_GRP2,0x00); //清接收完成标志
 687   2          }
 688   1          
 689   1          if(reg == 0x01)
 690   1          {
 691   2              if(TIMER18ms < 50) TIMER18ms = 50;
 692   2              Flag_RxDone = 1;
 693   2              ML7345_Write_Reg(ADDR_INT_SOURCE_GRP2,0x00); //清接收完成标志
 694   2              //ML7345_StateFlag_Clear(RX_DONE_FLAG); //清除后接收的数据会被清0
 695   2          }
 696   1          
 697   1          reg = ML7345_Read_Reg(ADDR_INT_SOURCE_GRP3);
 698   1          if(((reg & 0x01) == 0x01) && (reg != 0xff))
 699   1          {
 700   2              Flag_TxDone = 1;
 701   2              Time_APP_blank_TX = 6;
 702   2              ML7345_StateFlag_Clear(TX_DONE_FLAG);
 703   2          }
 704   1      }
 705          
 706          void RX_ANALYSIS(void)
 707          {
 708   1          xdata u8 i;
 709   1          for (i = 0; i < 7; i++)
 710   1          {
C51 COMPILER V9.60.0.0   ML7345                                                            04/15/2022 17:34:31 PAGE 13  

 711   2              SPI_Receive_DataForC[i] = (u32)SPI_RECEIVE_BUFF[i * 4 + 3] |
 712   2                                        (u32)SPI_RECEIVE_BUFF[i * 4 + 2] << 8 |
 713   2                                        (u32)SPI_RECEIVE_BUFF[i * 4 + 1] << 16 |
 714   2                                        (u32)SPI_RECEIVE_BUFF[i * 4 + 0] << 24;
 715   2          }
 716   1              if(Flag_ERROR_Read==0)
 717   1              {
 718   2             FLAG_Receiver_IDCheck = 1;
 719   2             ID_Decode_IDCheck();
 720   2              }
 721   1      }
 722          
 723          void SCAN_RECEIVE_PACKET(void)
 724          {
 725   1          xdata short Cache;
 726   1          if(Flag_RxDone)
 727   1          {
 728   2              Flag_RxDone = 0;
 729   2              if(PROFILE_CH_FREQ_32bit_200002EC == 426075000)
 730   2              {
 731   3                  if(Flag_TX_ID_load == 1)    ML7345_ReadRx_Pack(SPI_RECEIVE_BUFF,24);
 732   3                  else                        ML7345_ReadRx_Pack(SPI_RECEIVE_BUFF,12);
 733   3              }
 734   2              else    ML7345_ReadRx_Pack(SPI_RECEIVE_BUFF,28);
 735   2              ML7345_StateFlag_Clear(RX_DONE_FLAG);
 736   2              RX_ANALYSIS();
 737   2              Flag_FREQ_Scan = 0;
 738   2      
 739   2              ML7345_SetAndGet_State(Force_TRX_OFF);
 740   2              Cache = ML7345_Read_Reg(ADDR_ED_RSLT);
 741   2              RAM_RSSI_SUM += Cache;
 742   2              RSSI_Read_Counter++;
 743   2              RAM_RSSI_AVG = RAM_RSSI_SUM / RSSI_Read_Counter;
 744   2              ML7345_Write_Reg(0x00,0x22);    // Bank1 Set
 745   2              ML7345_Write_Reg(0x2a,0x55);    //sync
 746   2              ML7345_Write_Reg(0x00,0x11);    // Bank0 Set
 747   2              ML7345_SetAndGet_State(RX_ON);
 748   2              CG2214M6_USE_R;
 749   2              Flag_rx_pream = 0;
 750   2              TIMER18ms = 28;
 751   2          }
 752   1      }
 753          /*
 754          void ML7345D_Error_Detect(void)
 755          {
 756              if(ML7345_Read_Reg(ADDR_INT_SOURCE_GRP1) & 0x04)    //PLL unlock interrupt
 757              {
 758                  ML7345_Write_Reg(ADDR_INT_SOURCE_GRP1,0xFB);
 759                  while(ML7345_SetAndGet_State(Get_Sta) != TRX_OFF);
 760                  ML7345_AutoTx_Data(CONST_TXPACKET_DATA_20000AF0,28);
 761              }
 762              else if(ML7345_Read_Reg(ADDR_INT_SOURCE_GRP3) & 0x10)    //TX FIFO access error interrupt
 763              {
 764                  ML7345_SetAndGet_State(Force_TRX_OFF);
 765                  ML7345_StateFlag_Clear(TX_DONE_FLAG);
 766                  ML7345_AutoTx_Data(CONST_TXPACKET_DATA_20000AF0,28);
 767              }
 768          }*/
 769          
 770          /*
 771          void TX_DataLoad(u32 IDCache, u8 CtrCmd, u8 *Packet)
 772          {
C51 COMPILER V9.60.0.0   ML7345                                                            04/15/2022 17:34:31 PAGE 14  

 773              xdata u8 i;
 774              xdata u16 CRCTemp = 0;
 775              CRCTemp = (IDCache & 0xffff) + (((IDCache >> 16) & 0xff) + ((u16)CtrCmd << 8));
 776              for (i = 0; i < 24; i++)
 777              {
 778                  *(Packet + (i / 4)) <<= 2;
 779                  *(Packet + (i / 4)) |= ((IDCache & ((u32)1 << i)) ? 2 : 1);
 780              }
 781              for (i = 24; i < 32; i++)
 782              {
 783                  *(Packet + (i / 4)) <<= 2;
 784                  *(Packet + (i / 4)) |= ((CtrCmd & ((u8)1 << (i - 24))) ? 2 : 1);
 785              }
 786              for (i = 32; i < 48; i++)
 787              {
 788                  *(Packet + (i / 4)) <<= 2;
 789                  *(Packet + (i / 4)) |= ((CRCTemp & ((u16)1 << (i - 32))) ? 2 : 1);
 790              }
 791              ClearWDT();
 792          }*/
 793          
 794          void TX_DataLoad_HighSpeed(u32 IDCache, Wireless_Body CtrCmd, u8 *Packet)
 795          {
 796   1          xdata u8 i;
 797   1          xdata u16 CRCTemp = 0;
 798   1      
 799   1          CRCTemp = (IDCache & 0xffff) + (((IDCache >> 16) & 0xff) + ((u16)CtrCmd.Fno_Type.byte << 8));
 800   1              for(i=0;i<4;i++)
 801   1                      CRCTemp+=CtrCmd.Data[i].ui;
 802   1      
 803   1          for (i = 0; i < 24; i++)
 804   1          {
 805   2              *(Packet + (i / 4)) <<= 2;
 806   2              *(Packet + (i / 4)) |= ((IDCache & ((u32)1 << i)) ? 2 : 1);
 807   2          }
 808   1          for (i = 24; i < 32; i++)
 809   1          {
 810   2              *(Packet + (i / 4)) <<= 2;
 811   2              *(Packet + (i / 4)) |= ((CtrCmd.Fno_Type.byte & ((u8)1 << (i - 24))) ? 2 : 1);
 812   2          }
 813   1              ClearWDT();
 814   1          for (i = 32; i < 48; i++)
 815   1          {
 816   2              *(Packet + (i / 4)) <<= 2;
 817   2              *(Packet + (i / 4)) |= ((CtrCmd.Data[0].ui & ((u16)1 << (i - 32))) ? 2 : 1);
 818   2          }
 819   1          for (i = 48; i < 64; i++)
 820   1          {
 821   2              *(Packet + (i / 4)) <<= 2;
 822   2              *(Packet + (i / 4)) |= ((CtrCmd.Data[1].ui & ((u16)1 << (i - 48))) ? 2 : 1);
 823   2          }
 824   1              ClearWDT();
 825   1          for (i = 64; i < 80; i++)
 826   1          {
 827   2              *(Packet + (i / 4)) <<= 2;
 828   2              *(Packet + (i / 4)) |= ((CtrCmd.Data[2].ui & ((u16)1 << (i - 64))) ? 2 : 1);
 829   2          }
 830   1          for (i = 80; i < 96; i++)
 831   1          {
 832   2              *(Packet + (i / 4)) <<= 2;
 833   2              *(Packet + (i / 4)) |= ((CtrCmd.Data[3].ui & ((u16)1 << (i - 80))) ? 2 : 1);
 834   2          }
C51 COMPILER V9.60.0.0   ML7345                                                            04/15/2022 17:34:31 PAGE 15  

 835   1          ClearWDT();
 836   1          for (i = 96; i < 112; i++)
 837   1          {
 838   2              *(Packet + (i / 4)) <<= 2;
 839   2              *(Packet + (i / 4)) |= ((CRCTemp & ((u16)1 << (i - 96))) ? 2 : 1);
 840   2          }
 841   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7042    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    133    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     25    ----
   IDATA SIZE       =      1    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
